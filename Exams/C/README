Name: Bar Melinarskiy
ID: 318189982
CS-USER: bar246802

SpreaderDetectorBackend
-----------------------------
Please explain how you dealt with the following parts of the exam.

Input processing
----------------
1) תחילה בדקתי שאכן התקבלו 3 קלטים (שם התוכנית ו2 הנתינים לקבצים)
לא היה ברור לי אם צריך לבדוק שאכן הקבצים מסתיימים בסיומות של Meetings.in וPeople.in) - תחילה הוספתי בדיקה על זה אבל אז חשבתי שזה יכול להגביל טסטים שלכם אז הורדתי את הבידקה הזו

2) לאחר מכן, שלפתי את המידע מהקובץ People.in
עברתי שורה-שורה על הקובץ ובכל שורה הפרדתי לפי רווח למרכיבים שלה 
כאשר נתתי התייחסות בהתאם לכל סוג פרמטר וההמרה שהוא צריך
במיוחד נתתי התייחסות לשם שך היוזר והקצתי לו זיכרון דינמי כנדרש
את הפמרטרים האלו שמרתי בתוך struc שמייצג בן אדם ואותו הכנסתי למערך הדינאמי של האנשים
את המערך הגדלתי כל פעם ב-1.. העדפתי כל פעם לבקש בדיוק משאבים למערך ולא יותר ממה שצריך

סה"כ אם היו n אנשים בקובץ הקלט אז לקח לי O(n) כדי לעבד אותם (כי עברתי על כל השורות ועבור כל שורה עולה O(1)

לאחר מכן מיינתי את המערך של האנשים לפי ת"ז כדי שיהיה מהיר יותר לשלוף אותם בעתיד - O(nlogn)

4) ואז עברתי לעבד את Meetings.in
אסביר בחלק הבא על מדוע החלטתי לא לשמור את המידע של כל פגישה בעץ או מבנה נותנים אחרים אלא ישירות חשבתי מכל פגישה את המידע של הסיכון ואותו שמרתי לבן אדם הרלוונטי
גם פה עברתי בקובץ שורה-שורה ופירקתי לפרמטרים הרלוונטים

אם היו m פגישות אז עבור כל פגישה שלפתי את המידע של הבן אדם השני - O(n)
ולאחר מכן הכנסתי אותו לערמה מה שדורש O(logm)
כלומר סה"כ נקבל
O(m(logm +n))

בכל שלב בדקתי אם "התקשורת" עם הקבצים תקינה ובמידה ולא (קובץ לא נפתח/קובץ לא נסגר/בן אדם לא נמצא וכו') אז שחררתי את כל הזיכרונות הדינמאיים ויצאתי עם הודעת שגיאה רלוונטית

Data storing
------------
את המידע מהקובץ הראשון על האנשים שמרתי במערך דינאמי של struc שיצרתי המייצג בן אדם

התלבטתי רבות אם יש צורך לשמור את המידע של כל פגישה אבל נראה שספציפית בתרגיל הזה לא היה באמת צורך לשמור לשימוש עתידי את המידע הזה אלא היה אפשר לעבד אותו "תוך כדי ריצה" וכך עשיתי -
עבור כל בן בן אדם שנחשף למישהו בפגישה הוספתי את המידע שלו יחד עם הסיכוי הידבקות שלו לערמת מקסימום/תור קדימות (העניין של דחיפות בטיפול ישר זרק אותי לתור קדימות..)
כלומר עבור פגישה נתונה אני שלפתי מהערמה את הפגישה של המקור הנוכחי, ובאמצעותו יכולתי לעשות את שרשרת ההכפלות (כמו שמתוארת בעמוד 5 בPDF) יחד עם פרטי הפגישה הנוכחית
לאחר מכן כמובן שהיה צורך לתקן את הערמה כדי לשמור את התכונות של ערמת מקיסמום

כמו כן, עבור כל בן אדם שהיה בפגישה הדלקתי "דגל" השמור במערך של האנשים כדי לדעת בהמשך אם להדפיס אותו  כבריא


Results sorting
---------------
למעשה את רוב המיון נעשה תוך כדי עיבוד הקלט של הפגישות
עכשיו נותר היה רק לקרוא על כל גדול ערימת הקמסימום לשליפה של האיבר המקסימלי בה (לפי סיכון) ולהדפיס לקובץ הפלט את ההודעה המתאימה
כמובן שבכל פעם שחילצנו את המקסימום היה עלינו לתקן את הערמה מחדש

לבסוף, עברתי על כל האנשים שלא נפגשו עם אחד (בהתאם לדגל ששמרתי במערך של האנשים) והוספתי אותם לקובץ הפלט .. בסוף יצא שזה באמת היה כמו בסדר קליטה שלהם כמו שרציתם ואז וויתרתם על הדרישה

מייון הערמה דורש O(logm) כאשר כאמור m זה מספר הפגישות

למעשה אנו עוברים על כל הפגישות וכל פעם מחלצים את המקסימום הנוכחי - אז נקבל O(mlogm)
ולאחר מכן אנו שולפים את כל האנשים שלא נפגשו עם אף אחד - O(n) כאשר n זה כאמור מספר האנשים שקלטו


מקווה שהסברתי את עצמי טוב.. תמיד לוקח לי זמן לרשום אפיונים (לא הצד החזק שלי)

תודה מראש,
בר





